memmem:
   30|    420|void *memmem(const void *haystack, size_t n1, const void *needle, size_t n2) {
   31|    420|    const unsigned char *p1 = haystack;
   32|    420|    const unsigned char *p2 = needle;
   33|       |
   34|    420|    if (n2 == 0) return (void *) p1;
  ------------------
  |  Branch (34:9): [True: 0, False: 420]
  ------------------
   35|    420|    if (n2 > n1) return NULL;
  ------------------
  |  Branch (35:9): [True: 17, False: 403]
  ------------------
   36|       |
   37|    403|    const unsigned char *p3 = p1 + n1 - n2 + 1;
   38|    901|    for (const unsigned char *p = p1; (p = memchr(p, *p2, p3 - p)) != NULL; p++) {
  ------------------
  |  Branch (38:39): [True: 886, False: 15]
  ------------------
   39|    886|        if (!memcmp(p, p2, n2)) return (void *) p;
  ------------------
  |  Branch (39:13): [True: 388, False: 498]
  ------------------
   40|    886|    }
   41|       |
   42|     15|    return NULL;
   43|    403|}
hex_to_bin:
   46|     32|void hex_to_bin(const char *str, uint8_t *bytes, size_t blen) {
   47|     32|    uint8_t pos;
   48|     32|    uint8_t idx0;
   49|     32|    uint8_t idx1;
   50|       |
   51|       |    // mapping of ASCII characters to hex values
   52|     32|    const uint8_t hashmap[] = {
   53|     32|        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,  // 01234567
   54|     32|        0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 89:;<=>?
   55|     32|        0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00,  // @ABCDEFG
   56|     32|        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // HIJKLMNO
   57|     32|    };
   58|       |
   59|     32|    memset(bytes, 0, blen);
   60|  1.08k|    for (pos = 0; ((pos < (blen * 2)) && (pos < strlen(str))); pos += 2) {
  ------------------
  |  Branch (60:20): [True: 1.05k, False: 32]
  |  Branch (60:42): [True: 1.05k, False: 0]
  ------------------
   61|  1.05k|        idx0 = ((uint8_t) str[pos + 0] & 0x1F) ^ 0x10;
   62|  1.05k|        idx1 = ((uint8_t) str[pos + 1] & 0x1F) ^ 0x10;
   63|  1.05k|        bytes[pos / 2] = (uint8_t) (hashmap[idx0] << 4) | hashmap[idx1];
   64|  1.05k|    };
   65|     32|}
LLVMFuzzerTestOneInput:
   67|     32|int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
   68|     32|    hex_to_bin("0356959464545aa2787984fe4ac76496721a22f150c0076724ad7190fe3a597bb7",
   69|     32|               pub_key_bytes,
   70|     32|               PUBLIC_KEY_COMPRESSED_LEN);
  ------------------
  |  |   60|     32|#define PUBLIC_KEY_COMPRESSED_LEN 33
  ------------------
   71|       |
   72|       |    // =============================================
   73|       |    // Split input into multiple instructions based on separator == "deadbeef"
   74|       |    // =============================================
   75|     32|    uint8_t *haystack = (uint8_t*)Data;
   76|     32|    size_t haystack_len = Size;
   77|       |    // sep = 0x 64 65 61 64 62 65 65 66 => deadbeef in ascii
   78|     32|    const uint8_t separator[] = {0x64, 0x65, 0x61, 0x64, 0x62, 0x65, 0x65, 0x66};
   79|     32|    int separator_len = 8;
   80|       |
   81|     32|    int tx_byte_count = 0;
   82|     32|    int total_number_of_instructions = 0;
   83|     32|    const int max_splits = 500;
   84|     32|    const int max_instruction_size = 5000;
   85|     32|    uint8_t splits[max_splits][max_instruction_size];  // will never have more than 50 instructions
   86|     32|    size_t split_sizes[max_splits];
   87|       |
   88|    420|    while (1) {
  ------------------
  |  Branch (88:12): [Folded - Ignored]
  ------------------
   89|    420|        uint8_t *separator_start = memmem(haystack, haystack_len, separator, separator_len);
   90|       |
   91|    420|        if (separator_start != NULL) {
  ------------------
  |  Branch (91:13): [True: 388, False: 32]
  ------------------
   92|       |            // compute index of where separator was found
   93|    388|            int separator_index = separator_start - haystack;
   94|    388|            size_t split_size = separator_index;
   95|       |
   96|    388|            if (split_size > 0) {
  ------------------
  |  Branch (96:17): [True: 282, False: 106]
  ------------------
   97|    282|                memcpy(splits[total_number_of_instructions], haystack, split_size);
   98|       |
   99|    282|                split_sizes[total_number_of_instructions] = split_size;
  100|    282|                tx_byte_count += split_size;
  101|    282|                total_number_of_instructions += 1;
  102|    282|            }
  103|       |
  104|       |            // advance haystack to next part
  105|    388|            haystack = haystack + separator_index + separator_len;
  106|    388|            haystack_len -= (separator_index + separator_len);
  107|    388|        } else {
  108|     32|            break;
  109|     32|        }
  110|    420|    }
  111|       |
  112|       |    // if we didn't find any split, pass the whole input as a transaction
  113|     32|    if (tx_byte_count == 0) {
  ------------------
  |  Branch (113:9): [True: 7, False: 25]
  ------------------
  114|      7|        tx_byte_count = Size;
  115|      7|        total_number_of_instructions = 1;
  116|      7|        memcpy(splits[0], Data, Size);
  117|      7|        split_sizes[0] = Size;
  118|      7|    }
  119|       |
  120|       |    // =============================================
  121|       |    // Init transaction metadata
  122|       |    // =============================================
  123|     32|    transaction_parser_t tx_parser;
  124|     32|    parse_and_process_instruction_outcome_t outcome;
  125|       |
  126|     32|    memset(&tx_parser, 0, sizeof(tx_parser));
  127|       |
  128|     32|    const bip32_path_t bip32_path = (bip32_path_t){
  129|     32|        .path = {0x8000002C, 0x80000218, 0x80000002, 1, 3},
  130|     32|        .path_len = 5,
  131|     32|    };
  132|       |
  133|     32|    transaction_metadata_t transaction_metadata = (transaction_metadata_t){
  134|     32|        .tx_byte_count = tx_byte_count,
  135|     32|        .tx_bytes_received_count = (uint32_t) 0,
  136|     32|        .total_number_of_instructions = total_number_of_instructions,
  137|     32|        .number_of_instructions_received = (uint16_t) 0,
  138|     32|        .hrp_non_native_token = {0x00},
  139|     32|        .hrp_non_native_token_len = (uint8_t) 0,
  140|     32|    };
  141|       |
  142|     32|    instruction_display_config_t ins_display_config = (instruction_display_config_t){
  143|     32|        .display_substate_contents = true,
  144|     32|        .display_tx_summary = true,
  145|     32|    };
  146|       |
  147|     32|    init_transaction_parser_config_t tx_parser_config = (init_transaction_parser_config_t){
  148|     32|        .transaction_metadata = transaction_metadata,
  149|     32|        .instruction_display_config = ins_display_config,
  150|     32|        .bip32_path = bip32_path,
  151|     32|    };
  152|       |
  153|     32|    init_tx_parser_outcome_t init_tx_parser_outcome;
  154|       |
  155|     32|    const bool init_tx_parser_successful = init_tx_parser_with_config(&tx_parser,
  156|     32|                                                                      &always_derive_44_536_2_1_3,
  157|     32|                                                                      &update_sha256_hasher_hash,
  158|     32|                                                                      &init_sha256_hasher,
  159|     32|                                                                      &tx_parser_config,
  160|     32|                                                                      &init_tx_parser_outcome);
  161|     32|    memset(&outcome, 0, sizeof(outcome));
  162|       |
  163|       |    // =============================================
  164|       |    // Parse each instruction
  165|       |    // =============================================
  166|    321|    for (int i = 0; i < total_number_of_instructions; i++) {
  ------------------
  |  Branch (166:21): [True: 289, False: 32]
  ------------------
  167|    289|        buffer_t buf;
  168|    289|        buf.offset = 0;
  169|    289|        buf.size = split_sizes[i];
  170|    289|        buf.ptr = splits[i];
  171|    289|        parse_and_process_instruction_from_buffer(&buf, &tx_parser, &outcome);
  172|    289|    }
  173|       |
  174|     32|    return 0;
  175|     32|}
fuzz_tx_parser.c:always_derive_44_536_2_1_3:
   12|     32|static bool always_derive_44_536_2_1_3(derived_public_key_t *key) {
   13|     32|    key->address.address_type = RE_ADDRESS_PUBLIC_KEY;
   14|     32|    memmove(key->address.public_key.compressed, pub_key_bytes, PUBLIC_KEY_COMPRESSED_LEN);
  ------------------
  |  |   60|     32|#define PUBLIC_KEY_COMPRESSED_LEN 33
  ------------------
   15|     32|    return true;
   16|     32|}
fuzz_tx_parser.c:update_sha256_hasher_hash:
   22|    102|static bool update_sha256_hasher_hash(buffer_t *buf, bool final, uint8_t *out) {
   23|    102|    sha256_update(&sha256_ctx, buf->ptr, buf->size);
   24|    102|    if (final) {
  ------------------
  |  Branch (24:9): [True: 10, False: 92]
  ------------------
   25|     10|        sha256_final(&sha256_ctx, out);
   26|     10|    }
   27|    102|    return true;  // never fails
   28|    102|}
fuzz_tx_parser.c:init_sha256_hasher:
   18|     37|static void init_sha256_hasher() {
   19|     37|    sha256_init(&sha256_ctx);
   20|     37|}

read_u16_be:
   20|     46|uint16_t read_u16_be(const uint8_t *ptr, size_t offset) {
   21|     46|    return (uint16_t) ptr[offset + 0] << 8 |  //
   22|     46|           (uint16_t) ptr[offset + 1] << 0;
   23|     46|}
read_u32_be:
   25|     22|uint32_t read_u32_be(const uint8_t *ptr, size_t offset) {
   26|     22|    return (uint32_t) ptr[offset + 0] << 24 |  //
   27|     22|           (uint32_t) ptr[offset + 1] << 16 |  //
   28|     22|           (uint32_t) ptr[offset + 2] << 8 |   //
   29|     22|           (uint32_t) ptr[offset + 3] << 0;
   30|     22|}

parse_instruction:
   32|    289|                       re_instruction_t *instruction) {
   33|    289|    uint8_t re_instruction_type_value;
   34|    289|    if (!buffer_read_u8(buffer, &re_instruction_type_value) ||
  ------------------
  |  Branch (34:9): [True: 0, False: 289]
  ------------------
   35|    289|        !is_re_ins_type_known((int) re_instruction_type_value)) {
  ------------------
  |  Branch (35:9): [True: 51, False: 238]
  ------------------
   36|     51|        PRINTF("ERROR unrecognized instruction type: %d\n", re_instruction_type_value);
   37|     51|        outcome->outcome_type = PARSE_INS_FAIL_UNRECOGNIZED_INSTRUCTION_TYPE;
   38|     51|        outcome->unrecognized_instruction_type_value = re_instruction_type_value;
   39|     51|        return false;
   40|     51|    }
   41|       |
   42|    238|    if (!is_re_ins_type_supported((int) re_instruction_type_value)) {
  ------------------
  |  Branch (42:9): [True: 12, False: 226]
  ------------------
   43|     12|        PRINTF("ERROR unsupported instruction type: %d\n", re_instruction_type_value);
   44|     12|        outcome->outcome_type = PARSE_INS_FAIL_UNSUPPORTED_INSTRUCTION_TYPE;
   45|     12|        outcome->unsupported_instruction_type_value = re_instruction_type_value;
   46|     12|        return false;
   47|     12|    }
   48|       |
   49|    226|    instruction->ins_type = (re_instruction_type_e) re_instruction_type_value;
   50|       |
   51|       |    // print_re_ins_type(instruction->ins_type);
   52|       |
   53|    226|    switch (instruction->ins_type) {
  ------------------
  |  Branch (53:13): [True: 0, False: 226]
  ------------------
   54|     75|        case INS_DOWN:
  ------------------
  |  Branch (54:9): [True: 75, False: 151]
  ------------------
   55|     75|            if (!parse_substate_id(buffer,
  ------------------
  |  Branch (55:17): [True: 53, False: 22]
  ------------------
   56|     75|                                   &outcome->substate_id_failure,
   57|     75|                                   &instruction->ins_down.substate_id)) {
   58|     53|                PRINTF("Failed to parse substate id for INS_DOWN.\n");
   59|     53|                outcome->outcome_type = PARSE_INS_FAILED_TO_PARSE_SUBSTATE_ID;
   60|     53|                return false;
   61|     53|            }
   62|     22|            PRINTF("Finished parsing substate ID for INS_DOWN.\n");
   63|     22|            break;
   64|       |
   65|      0|        case INS_READ:
  ------------------
  |  Branch (65:9): [True: 0, False: 226]
  ------------------
   66|      0|            if (!parse_substate_id(buffer,
  ------------------
  |  Branch (66:17): [True: 0, False: 0]
  ------------------
   67|      0|                                   &outcome->substate_id_failure,
   68|      0|                                   &instruction->ins_read.substate_id)) {
   69|      0|                PRINTF("Failed to parse substate id for INS_READ.\n");
   70|      0|                outcome->outcome_type = PARSE_INS_FAILED_TO_PARSE_SUBSTATE_ID;
   71|      0|                return false;
   72|      0|            }
   73|      0|            PRINTF("Finished parsing substate ID for INS_READ.\n");
   74|      0|            break;
   75|       |
   76|      0|        case INS_LDOWN:
  ------------------
  |  Branch (76:9): [True: 0, False: 226]
  ------------------
   77|      0|            if (!parse_substate_index(buffer, &instruction->ins_ldown.substate_index)) {
  ------------------
  |  Branch (77:17): [True: 0, False: 0]
  ------------------
   78|      0|                PRINTF("Failed to parse substate index.\n");
   79|      0|                outcome->outcome_type = PARSE_INS_FAILED_TO_PARSE_SUBSTATE_INDEX;
   80|      0|                return false;
   81|      0|            }
   82|      0|            PRINTF("Finished parsing substate index.\n");
   83|      0|            break;
   84|     20|        case INS_UP:
  ------------------
  |  Branch (84:9): [True: 20, False: 206]
  ------------------
   85|     20|            if (!parse_substate(buffer,
  ------------------
  |  Branch (85:17): [True: 6, False: 14]
  ------------------
   86|     20|                                &outcome->substate_failure,
   87|     20|                                &instruction->ins_up.substate)) {
   88|      6|                PRINTF("Failed to parse substate for INS_UP.\n");
   89|      6|                outcome->outcome_type = PARSE_INS_FAILED_TO_PARSE_SUBSTATE;
   90|      6|                return false;
   91|      6|            }
   92|     14|            PRINTF("Finished parsing substate.\n");
   93|     14|            break;
   94|      0|        case INS_VREAD:
  ------------------
  |  Branch (94:9): [True: 0, False: 226]
  ------------------
   95|      0|            if (!parse_virtual_substate_id(buffer)) {
  ------------------
  |  Branch (95:17): [True: 0, False: 0]
  ------------------
   96|      0|                PRINTF("Failed to parse virtual substate id for INS_VREAD.\n");
   97|      0|                outcome->outcome_type = PARSE_INS_INVALID_VIRTUAL_SUBSTATE_ID;
   98|      0|                return false;
   99|      0|            }
  100|      0|            PRINTF("Finished parsing virtual substate id.\n");
  101|      0|            break;
  102|       |
  103|     43|        case INS_END:
  ------------------
  |  Branch (103:9): [True: 43, False: 183]
  ------------------
  104|     43|            PRINTF("Finished parsing END of substate group (empty, nothing to parse).\n");
  105|     43|            break;
  106|       |
  107|      0|        case INS_MSG:  // Attached Message
  ------------------
  |  Branch (107:9): [True: 0, False: 226]
  ------------------
  108|      0|            if (!parse_re_bytes(buffer, &outcome->message_failure, &instruction->ins_msg.message)) {
  ------------------
  |  Branch (108:17): [True: 0, False: 0]
  ------------------
  109|      0|                PRINTF("Failed to parse INS_MSG.\n");
  110|      0|                outcome->outcome_type = PARSE_INS_FAILED_TO_PARSE_MSG;
  111|      0|                return false;
  112|      0|            }
  113|      0|            PRINTF("Finished parsing attached message.\n");
  114|      0|            break;
  115|     34|        case INS_SYSCALL:  // e.g. (only?= Transaction fee amount
  ------------------
  |  Branch (115:9): [True: 34, False: 192]
  ------------------
  116|     34|            if (!parse_re_bytes(buffer,
  ------------------
  |  Branch (116:17): [True: 17, False: 17]
  ------------------
  117|     34|                                &outcome->syscall_failure,
  118|     34|                                &instruction->ins_syscall.call_data)) {
  119|     17|                PRINTF("Failed to parse INS_SYSCALL.\n");
  120|     17|                outcome->outcome_type = PARSE_INS_FAILED_TO_PARSE_SYSCALL;
  121|     17|                return false;
  122|     17|            }
  123|       |
  124|     17|            PRINTF("Finished parsing syscall (tx fee).\n");
  125|     17|            break;
  126|     54|        case INS_HEADER:
  ------------------
  |  Branch (126:9): [True: 54, False: 172]
  ------------------
  127|     54|            if (!buffer_read_u8(buffer, &instruction->ins_header.version) ||
  ------------------
  |  Branch (127:17): [True: 0, False: 54]
  ------------------
  128|     54|                !buffer_read_u8(buffer, &instruction->ins_header.flag)) {
  ------------------
  |  Branch (128:17): [True: 0, False: 54]
  ------------------
  129|      0|                PRINTF("Failed to parse INS_HEADER.\n");
  130|      0|                outcome->outcome_type = PARSE_INS_FAILED_TO_PARSE_HEADER;
  131|      0|                return false;
  132|      0|            }
  133|     54|            if (instruction->ins_header.version != INS_HEADER_REQUIRED_VERSION) {
  ------------------
  |  |   19|     54|#define INS_HEADER_REQUIRED_VERSION                           0x00
  ------------------
  |  Branch (133:17): [True: 8, False: 46]
  ------------------
  134|      8|                PRINTF("Parsed INS_HEADER has incorrect 'version', expected: %d, but got: %d.\n",
  135|      8|                       INS_HEADER_REQUIRED_VERSION,
  136|      8|                       instruction->ins_header.version);
  137|      8|                outcome->outcome_type = PARSE_INS_INVALID_HEADER;
  138|      8|                return false;
  139|      8|            }
  140|     46|            if (instruction->ins_header.flag !=
  ------------------
  |  Branch (140:17): [True: 8, False: 38]
  ------------------
  141|     46|                INS_HEADER_FLAG_DISALLOWING_TOKEN_BURN_AND_TOKEN_MINT) {
  ------------------
  |  |   20|     46|#define INS_HEADER_FLAG_DISALLOWING_TOKEN_BURN_AND_TOKEN_MINT 0x01
  ------------------
  142|      8|                PRINTF(
  143|      8|                    "Parsed INS_HEADER has incorrect 'flag', expected: %d, but got: %d.\nThis flag "
  144|      8|                    "is extremely important since it is a protocol enforced option that prevents a "
  145|      8|                    "transaction from containing token minting and token burning. But since it is "
  146|      8|                    "quite complex to implement those instruction we use these flag as a simpler "
  147|      8|                    "solution.\n",
  148|      8|                    INS_HEADER_FLAG_DISALLOWING_TOKEN_BURN_AND_TOKEN_MINT,
  149|      8|                    instruction->ins_header.flag);
  150|      8|                outcome->outcome_type = PARSE_INS_INVALID_HEADER;
  151|      8|                return false;
  152|      8|            }
  153|     38|            PRINTF(
  154|     38|                "Finished parsing header. We have asserted that thix transaction CANNOT contain "
  155|     38|                "any instructions to burn or mint new tokens.\n");
  156|     38|            break;
  157|    226|    }
  158|       |
  159|    134|    outcome->outcome_type = (number_of_remaining_bytes_in_buffer(buffer) == 0)
  ------------------
  |  Branch (159:29): [True: 101, False: 33]
  ------------------
  160|    134|                                ? PARSE_INS_OK
  161|    134|                                : PARSE_INS_CONTAINS_EXTRA_BYTES;
  162|       |
  163|    134|    return outcome->outcome_type == PARSE_INS_OK;
  164|    226|}

is_re_ins_type_known:
    3|    289|bool is_re_ins_type_known(int raw) {
    4|    289|    return raw <= RE_INSTRUCTION_TYPE_LAST_KNOWN;
  ------------------
  |  |    6|    289|#define RE_INSTRUCTION_TYPE_LAST_KNOWN 0x13
  ------------------
    5|    289|}
is_re_ins_type_supported:
    7|    238|bool is_re_ins_type_supported(int raw) {
    8|    238|    switch (raw) {
    9|     75|        case INS_DOWN:     // Consuming UTXOs
  ------------------
  |  Branch (9:9): [True: 75, False: 163]
  ------------------
   10|     75|        case INS_LDOWN:    // Consuming UTXOs
  ------------------
  |  Branch (10:9): [True: 0, False: 238]
  ------------------
   11|     95|        case INS_UP:       // New substate
  ------------------
  |  Branch (11:9): [True: 20, False: 218]
  ------------------
   12|    138|        case INS_END:      // Marker for end of substate group ("action")
  ------------------
  |  Branch (12:9): [True: 43, False: 195]
  ------------------
   13|    138|        case INS_MSG:      // Attached Message
  ------------------
  |  Branch (13:9): [True: 0, False: 238]
  ------------------
   14|    192|        case INS_HEADER:   // Prevent burn/mint of tokens
  ------------------
  |  Branch (14:9): [True: 54, False: 184]
  ------------------
   15|    226|        case INS_SYSCALL:  // Tx fee
  ------------------
  |  Branch (15:9): [True: 34, False: 204]
  ------------------
   16|    226|        case INS_VREAD:
  ------------------
  |  Branch (16:9): [True: 0, False: 238]
  ------------------
   17|    226|        case INS_READ:
  ------------------
  |  Branch (17:9): [True: 0, False: 238]
  ------------------
   18|    226|            return true;
   19|     12|        default:
  ------------------
  |  Branch (19:9): [True: 12, False: 226]
  ------------------
   20|     12|            return false;
   21|    238|    }
   22|    238|}

parse_substate:
    5|     20|bool parse_substate(buffer_t *buffer, parse_substate_outcome_t *outcome, substate_t *substate) {
    6|     20|    uint16_t substate_size;
    7|       |
    8|     20|    if (!buffer_read_u16(buffer, &substate_size, BE)) {
  ------------------
  |  Branch (8:9): [True: 0, False: 20]
  ------------------
    9|      0|        outcome->outcome_type = PARSE_SUBSTATE_FAIL_UNRECOGNIZED_SUBSTATE_TYPE;
   10|      0|        return false;
   11|      0|    }
   12|       |
   13|     20|    uint8_t substate_type_value;
   14|     20|    if (!buffer_read_u8(buffer, &substate_type_value) ||
  ------------------
  |  Branch (14:9): [True: 0, False: 20]
  ------------------
   15|     20|        !is_re_substate_type_known((int) substate_type_value)) {
  ------------------
  |  Branch (15:9): [True: 0, False: 20]
  ------------------
   16|      0|        PRINTF("ERROR unrecognized substate type: %d\n", substate_type_value);
   17|      0|        outcome->outcome_type = PARSE_SUBSTATE_FAIL_UNRECOGNIZED_SUBSTATE_TYPE;
   18|      0|        outcome->unrecognized_substate_type_value = substate_type_value;
   19|      0|        return false;
   20|      0|    }
   21|       |
   22|     20|    if (!is_re_substate_type_supported((int) substate_type_value)) {
  ------------------
  |  Branch (22:9): [True: 3, False: 17]
  ------------------
   23|      3|        PRINTF("ERROR unsupported substate type: %d\n", substate_type_value);
   24|      3|        outcome->outcome_type = PARSE_SUBSTATE_FAIL_UNSUPPORTED_SUBSTATE_TYPE;
   25|      3|        outcome->unsupported_substate_type_value = substate_type_value;
   26|      3|        return false;
   27|      3|    }
   28|       |
   29|     17|    substate->type = (re_substate_type_e) substate_type_value;
   30|       |
   31|       |    // print_re_substate_type(substate->type);
   32|       |
   33|     17|    switch (substate->type) {
  ------------------
  |  Branch (33:13): [True: 0, False: 17]
  ------------------
   34|     17|        case SUBSTATE_TYPE_TOKENS:
  ------------------
  |  Branch (34:9): [True: 17, False: 0]
  ------------------
   35|     17|            if (!parse_tokens(buffer, &outcome->tokens_failure, &substate->tokens)) {
  ------------------
  |  Branch (35:17): [True: 3, False: 14]
  ------------------
   36|      3|                PRINTF("Failed to parse 'TOKENS'.\n");
   37|      3|                outcome->outcome_type = PARSE_SUBSTATE_FAILED_TO_PARSE_TOKENS;
   38|      3|                return false;
   39|      3|            }
   40|     14|            PRINTF("Successfully parsed substate of type 'TOKENS'.\n");
   41|     14|            break;
   42|      0|        case SUBSTATE_TYPE_PREPARED_STAKE:
  ------------------
  |  Branch (42:9): [True: 0, False: 17]
  ------------------
   43|      0|            if (!parse_prepared_stake(buffer,
  ------------------
  |  Branch (43:17): [True: 0, False: 0]
  ------------------
   44|      0|                                      &outcome->prepared_stake_failure,
   45|      0|                                      &substate->prepared_stake)) {
   46|      0|                PRINTF("Failed to parse 'PREPARE_STAKE'.\n");
   47|       |
   48|      0|                outcome->outcome_type = PARSE_SUBSTATE_FAILED_TO_PARSE_PREPARED_STAKE;
   49|      0|                return false;
   50|      0|            }
   51|      0|            PRINTF("Successfully parsed substate of type 'PREPARE_STAKE'.\n");
   52|      0|            break;
   53|      0|        case SUBSTATE_TYPE_STAKE_OWNERSHIP:
  ------------------
  |  Branch (53:9): [True: 0, False: 17]
  ------------------
   54|      0|            if (!parse_stake_ownership(buffer,
  ------------------
  |  Branch (54:17): [True: 0, False: 0]
  ------------------
   55|      0|                                       &outcome->stake_ownership_failure,
   56|      0|                                       &substate->stake_ownership)) {
   57|      0|                PRINTF("Failed to parse 'STAKE_OWNERSHIP'.\n");
   58|       |
   59|      0|                outcome->outcome_type = PARSE_SUBSTATE_FAILED_TO_PARSE_STAKE_OWNERSHIP;
   60|      0|                return false;
   61|      0|            }
   62|      0|            PRINTF("Successfully parsed substate of type 'STAKE_OWNERSHIP'.\n");
   63|      0|            break;
   64|      0|        case SUBSTATE_TYPE_PREPARED_UNSTAKE:
  ------------------
  |  Branch (64:9): [True: 0, False: 17]
  ------------------
   65|      0|            if (!parse_prepared_unstake(buffer,
  ------------------
  |  Branch (65:17): [True: 0, False: 0]
  ------------------
   66|      0|                                        &outcome->prepared_unstake_failure,
   67|      0|                                        &substate->prepared_unstake)) {
   68|      0|                PRINTF("Failed to parse 'PREPARE_UNSTAKE'.\n");
   69|      0|                outcome->outcome_type = PARSE_SUBSTATE_FAILED_TO_PARSE_PREPARED_UNSTAKE;
   70|      0|                return false;
   71|      0|            }
   72|      0|            PRINTF("Successfully parsed substate of type 'PREPARE_UNSTAKE'.\n");
   73|      0|            break;
   74|      0|        case SUBSTATE_TYPE_VALIDATOR_OWNER_COPY:
  ------------------
  |  Branch (74:9): [True: 0, False: 17]
  ------------------
   75|      0|            if (!parse_validator_owner_copy(buffer,
  ------------------
  |  Branch (75:17): [True: 0, False: 0]
  ------------------
   76|      0|                                            &outcome->validator_owner_copy_failure,
   77|      0|                                            &substate->validator_owner_copy)) {
   78|      0|                PRINTF("Failed to parse 'VALIDATOR_OWNER_COPY'.\n");
   79|      0|                outcome->outcome_type = PARSE_SUBSTATE_FAILED_TO_PARSE_VALIDATOR_OWNER_COPY;
   80|      0|                return false;
   81|      0|            }
   82|      0|            PRINTF("Successfully parsed substate of type 'VALIDATOR_OWNER_COPY'.\n");
   83|      0|            break;
   84|      0|        case SUBSTATE_TYPE_VALIDATOR_ALLOW_DELEGATION_FLAG:
  ------------------
  |  Branch (84:9): [True: 0, False: 17]
  ------------------
   85|      0|            if (!parse_validator_allow_delegation_flag(
  ------------------
  |  Branch (85:17): [True: 0, False: 0]
  ------------------
   86|      0|                    buffer,
   87|      0|                    &outcome->validator_allow_delegation_flag_failure,
   88|      0|                    &substate->validator_allow_delegation_flag)) {
   89|      0|                PRINTF("Failed to parse 'VALIDATOR_ALLOW_DELEGATION_FLAG'.\n");
   90|      0|                outcome->outcome_type =
   91|      0|                    PARSE_SUBSTATE_FAILED_TO_PARSE_VALIDATOR_ALLOW_DELEGATION_FLAG;
   92|      0|                return false;
   93|      0|            }
   94|      0|            PRINTF("Successfully parsed substate of type 'VALIDATOR_ALLOW_DELEGATION_FLAG'.\n");
   95|      0|            break;
   96|     17|    }
   97|     14|    outcome->outcome_type = PARSE_SUBSTATE_OK;
   98|     14|    return true;
   99|     17|}

parse_substate_id:
    8|     75|                       substate_id_t *substate_id) {
    9|       |    // Parse field 'hash'
   10|     75|    debug_print_buffer(buffer);
   11|       |
   12|     75|    PRINTF("\nAbout to parse SUBSTATE_ID, beginning with HASH, having length: %d.\n",
   13|     75|           SUBSTATE_ID_HASH_LEN);
   14|       |
   15|     75|    if (!buffer_move_fill_target(buffer, substate_id->hash, SUBSTATE_ID_HASH_LEN)) {
  ------------------
  |  |    7|     75|#define SUBSTATE_ID_HASH_LEN HASH_LEN
  |  |  ------------------
  |  |  |  |   48|     75|#define HASH_LEN 32
  |  |  ------------------
  ------------------
  |  Branch (15:9): [True: 53, False: 22]
  ------------------
   16|     53|        PRINTF("Failed to parse 'hash' in substate id.\n");
   17|     53|        *outcome = PARSE_SUBSTATE_ID_FAILED_HASH;
   18|     53|        return false;
   19|     53|    }
   20|       |
   21|     22|    if (!buffer_read_u32(buffer, &substate_id->index, BE)) {
  ------------------
  |  Branch (21:9): [True: 0, False: 22]
  ------------------
   22|      0|        PRINTF("Failed to parse 'index' in substate id.\n");
   23|      0|        *outcome = PARSE_SUBSTATE_ID_FAILED_INDEX;
   24|      0|        return false;
   25|      0|    }
   26|       |
   27|     22|    *outcome = PARSE_SUBSTATE_ID_OK;
   28|       |
   29|     22|    return true;
   30|     22|}

is_re_substate_type_known:
    3|     20|bool is_re_substate_type_known(uint8_t raw) {
    4|     20|    return raw <= RE_SUBSTATE_TYPE_LAST_KNOWN;
  ------------------
  |  |    6|     20|#define RE_SUBSTATE_TYPE_LAST_KNOWN 0x11
  ------------------
    5|     20|}
is_re_substate_type_supported:
    7|     20|bool is_re_substate_type_supported(uint8_t raw) {
    8|     20|    switch (raw) {
  ------------------
  |  Branch (8:13): [True: 3, False: 17]
  ------------------
    9|     17|        case SUBSTATE_TYPE_TOKENS:            // Token transfer
  ------------------
  |  Branch (9:9): [True: 17, False: 3]
  ------------------
   10|     17|        case SUBSTATE_TYPE_PREPARED_STAKE:    // Stake tokens
  ------------------
  |  Branch (10:9): [True: 0, False: 20]
  ------------------
   11|     17|        case SUBSTATE_TYPE_PREPARED_UNSTAKE:  // Unstake tokens
  ------------------
  |  Branch (11:9): [True: 0, False: 20]
  ------------------
   12|     17|        case SUBSTATE_TYPE_STAKE_OWNERSHIP:   // (part of unstake)
  ------------------
  |  Branch (12:9): [True: 0, False: 20]
  ------------------
   13|     17|        case SUBSTATE_TYPE_VALIDATOR_ALLOW_DELEGATION_FLAG:
  ------------------
  |  Branch (13:9): [True: 0, False: 20]
  ------------------
   14|     17|        case SUBSTATE_TYPE_VALIDATOR_OWNER_COPY:
  ------------------
  |  Branch (14:9): [True: 0, False: 20]
  ------------------
   15|     17|            return true;
   16|     20|    }
   17|      3|    return false;
   18|     20|}

parse_tokens:
    5|     17|bool parse_tokens(buffer_t *buffer, parse_tokens_outcome_t *outcome, tokens_t *tokens) {
    6|       |    // Parse field 'reserved'
    7|     17|    if (!buffer_read_u8(buffer, &tokens->reserved)) {
  ------------------
  |  Branch (7:9): [True: 0, False: 17]
  ------------------
    8|      0|        PRINTF("Failed to parse 'reserved' in substate 'TOKENS'.\n");
    9|      0|        outcome->outcome_type = PARSE_TOKENS_FAILURE_PARSE_RESERVED;
   10|      0|        return false;
   11|      0|    }
   12|       |
   13|       |    // Parse field 'owner'
   14|     17|    if (!parse_re_address(buffer, &outcome->owner_parse_failure_reason, &tokens->owner)) {
  ------------------
  |  Branch (14:9): [True: 1, False: 16]
  ------------------
   15|      1|        PRINTF("Failed to parse 'owner' in substate 'TOKENS'.\n");
   16|      1|        outcome->outcome_type = PARSE_TOKENS_FAILURE_PARSE_OWNER;
   17|      1|        return false;
   18|      1|    }
   19|     16|    if (tokens->owner.address_type != RE_ADDRESS_PUBLIC_KEY) {
  ------------------
  |  Branch (19:9): [True: 0, False: 16]
  ------------------
   20|       |        // Wrong address type in context of account address.
   21|      0|        outcome->outcome_type = PARSE_TOKENS_FAILURE_PARSE_OWNER;
   22|      0|        outcome->owner_parse_failure_reason =
   23|      0|            PARSED_ADDRESS_FAIL_EXPECTED_TYPE_COMPATIBLE_ACCOUNT_OR_VALIDATOR_ADDRESS;
   24|      0|        return false;
   25|      0|    }
   26|       |
   27|       |    // Parse field 'resource'
   28|     16|    if (!parse_re_address(buffer, &outcome->resource_parse_failure_reason, &tokens->resource)) {
  ------------------
  |  Branch (28:9): [True: 2, False: 14]
  ------------------
   29|      2|        PRINTF("Failed to parse 'resource' in substate 'TOKENS'.\n");
   30|      2|        outcome->outcome_type = PARSE_TOKENS_FAILURE_PARSE_RESOURCE;
   31|      2|        return false;
   32|      2|    }
   33|     14|    if (tokens->resource.address_type != RE_ADDRESS_HASHED_KEY_NONCE &&
  ------------------
  |  Branch (33:9): [True: 10, False: 4]
  ------------------
   34|     14|        tokens->resource.address_type != RE_ADDRESS_NATIVE_TOKEN) {
  ------------------
  |  Branch (34:9): [True: 0, False: 10]
  ------------------
   35|       |        // Wrong address type in context of Resource.
   36|      0|        outcome->outcome_type = PARSE_TOKENS_FAILURE_PARSE_RESOURCE;
   37|      0|        outcome->resource_parse_failure_reason =
   38|      0|            PARSED_ADDRESS_FAIL_EXPECTED_TYPE_COMPATIBLE_WITH_RESOURCE;
   39|      0|        return false;
   40|      0|    }
   41|       |
   42|       |    // Parse field 'amount'
   43|     14|    if (!uint256_from_buffer(buffer, &tokens->amount)) {
  ------------------
  |  Branch (43:9): [True: 0, False: 14]
  ------------------
   44|      0|        PRINTF("Failed to parse 'amount' in substate 'TOKENS'.\n");
   45|      0|        outcome->outcome_type = PARSE_TOKENS_FAILURE_PARSE_AMOUNT;
   46|      0|        return false;
   47|      0|    }
   48|       |
   49|     14|    outcome->outcome_type = PARSE_TOKENS_OK;
   50|       |
   51|     14|    return true;
   52|     14|}

is_tx_fee_set:
    3|     15|bool is_tx_fee_set(const transaction_t *transaction) {
    4|     15|    return is_uint256_greater_than_zero(&transaction->tx_fee);
    5|     15|}

parse_tx_fee_from_syscall:
   38|     12|bool parse_tx_fee_from_syscall(re_ins_syscall_t *syscall, uint256_t *tx_fee) {
   39|     12|    if (syscall->call_data.length != 33) {
  ------------------
  |  Branch (39:9): [True: 2, False: 10]
  ------------------
   40|      2|        return false;
   41|      2|    }
   42|       |
   43|     10|    if (syscall->call_data.data[0] != INS_SYSCALL_TX_FEE_RESERVE_PUT &&
  ------------------
  |  |   16|     20|#define INS_SYSCALL_TX_FEE_RESERVE_PUT  0x00
  ------------------
  |  Branch (43:9): [True: 3, False: 7]
  ------------------
   44|     10|        syscall->call_data.data[0] != INS_SYSCALL_TX_FEE_RESERVE_TAKE) {
  ------------------
  |  |   17|      3|#define INS_SYSCALL_TX_FEE_RESERVE_TAKE 0x01
  ------------------
  |  Branch (44:9): [True: 0, False: 3]
  ------------------
   45|       |        // Only these two values above are known to relate to TX fee.
   46|      0|        return false;
   47|      0|    }
   48|       |
   49|     10|    readu256BE(syscall->call_data.data + 1, tx_fee);
   50|       |
   51|     10|    return true;
   52|     10|}
parse_and_process_instruction_from_buffer:
  144|    289|                                               parse_and_process_instruction_outcome_t *outcome) {
  145|    289|    instruction_parser_t *instruction_parser = &tx_parser->instruction_parser;
  146|       |
  147|       |    // Important to reset memory between subsequent instructions.
  148|    289|    explicit_bzero(&instruction_parser->instruction, sizeof(instruction_parser->instruction));
  149|       |
  150|       |    // Parse transaction: incoming Radix Engine instructions, one at a time.
  151|    289|    if (instruction_parser->state != STATE_PARSE_INS_READY_TO_PARSE) {
  ------------------
  |  Branch (151:9): [True: 0, False: 289]
  ------------------
  152|      0|        outcome->outcome_type = PARSE_PROCESS_INS_BAD_STATE;
  153|      0|        return false;
  154|      0|    }
  155|       |
  156|    289|    transaction_metadata_t *tx_metadata = &tx_parser->transaction_metadata;
  157|       |
  158|    289|    tx_metadata->tx_bytes_received_count += buffer->size;
  159|    289|    if (tx_metadata->tx_bytes_received_count > tx_metadata->tx_byte_count) {
  ------------------
  |  Branch (159:9): [True: 0, False: 289]
  ------------------
  160|      0|        outcome->outcome_type = PARSE_PROCESS_INS_BYTE_COUNT_MISMATCH;
  161|      0|        return false;
  162|      0|    }
  163|       |
  164|       |    // Parse newly received single Radix Engine instruction
  165|    289|    if (!parse_instruction(buffer, &outcome->parse_failure, &instruction_parser->instruction)) {
  ------------------
  |  Branch (165:9): [True: 188, False: 101]
  ------------------
  166|    188|        outcome->outcome_type = PARSE_PROCESS_INS_FAILED_TO_PARSE;
  167|    188|        return false;
  168|    188|    }
  169|       |
  170|    101|    tx_metadata->number_of_instructions_received += 1;
  171|       |
  172|    101|    if (instruction_parser->instruction.ins_type == INS_HEADER) {
  ------------------
  |  Branch (172:9): [True: 33, False: 68]
  ------------------
  173|     33|        bool mint_and_burn_is_forbidden = instruction_parser->instruction.ins_header.flag ==
  174|     33|                                          INS_HEADER_FLAG_DISALLOWING_TOKEN_BURN_AND_TOKEN_MINT;
  ------------------
  |  |   20|     33|#define INS_HEADER_FLAG_DISALLOWING_TOKEN_BURN_AND_TOKEN_MINT 0x01
  ------------------
  175|     33|        tx_parser->transaction.have_asserted_no_mint_or_burn = mint_and_burn_is_forbidden;
  176|     33|    }
  177|       |
  178|       |    // Just finished parsing an instruction that was not INS_HEADER
  179|    101|    if (!tx_parser->transaction.have_asserted_no_mint_or_burn) {
  ------------------
  |  Branch (179:9): [True: 2, False: 99]
  ------------------
  180|       |        // ☠️  ILLEGAL TX: might burn/mint tokens ☠️
  181|      2|        outcome->outcome_type = PARSE_PROCESS_INS_DISABLE_MINT_AND_BURN_FLAG_NOT_SET;
  182|      2|        return false;
  183|      2|    }
  184|       |
  185|       |    // If instruction is SYSCALL, parse out bytes as transaction fee.
  186|     99|    if (instruction_parser->instruction.ins_type == INS_SYSCALL) {
  ------------------
  |  Branch (186:9): [True: 12, False: 87]
  ------------------
  187|     12|        if (!update_tx_fee_and_total_xrd_cost_if_needed(
  ------------------
  |  Branch (187:13): [True: 2, False: 10]
  ------------------
  188|     12|                &instruction_parser->instruction.ins_syscall,
  189|     12|                &tx_parser->transaction)) {
  190|      2|            outcome->outcome_type = PARSE_PROCESS_INS_PARSE_TX_FEE_FROM_SYSCALL_FAIL;
  191|      2|            return false;
  192|      2|        }
  193|     12|    }
  194|       |
  195|     97|    if (instruction_parser->instruction.ins_up.substate.type == SUBSTATE_TYPE_TOKENS) {
  ------------------
  |  Branch (195:9): [True: 14, False: 83]
  ------------------
  196|       |        // My public key matches owner of tokens
  197|     14|        bool token_amount_is_change_back_to_me = public_key_equals(
  198|     14|            &tx_parser->signing.my_derived_public_key.address.public_key,
  199|     14|            &instruction_parser->instruction.ins_up.substate.tokens.owner.public_key);
  200|       |
  201|       |        // I own the tokens and the rri matches XRD
  202|     14|        bool increment_xrd_grand_total =
  203|     14|            !token_amount_is_change_back_to_me &&
  ------------------
  |  Branch (203:13): [True: 11, False: 3]
  ------------------
  204|     14|            instruction_parser->instruction.ins_up.substate.tokens.resource.address_type ==
  ------------------
  |  Branch (204:13): [True: 9, False: 2]
  ------------------
  205|     11|                RE_ADDRESS_NATIVE_TOKEN;
  206|       |
  207|     14|        if (increment_xrd_grand_total) {
  ------------------
  |  Branch (207:13): [True: 9, False: 5]
  ------------------
  208|      9|            uint256_t tmp;
  209|       |            // Save current amount to avoid in-place update
  210|      9|            copy256(&tmp, &tx_parser->transaction.total_xrd_amount_incl_fee);
  211|       |
  212|       |            // Spending XRD => increment total XRD spent counter
  213|      9|            add256(&instruction_parser->instruction.ins_up.substate.tokens.amount,
  214|      9|                   &tmp,
  215|      9|                   &tx_parser->transaction.total_xrd_amount_incl_fee);
  216|      9|        }
  217|     14|    }
  218|       |
  219|     97|    bool was_last_apdu =
  220|     97|        tx_metadata->number_of_instructions_received == tx_metadata->total_number_of_instructions;
  221|       |
  222|     97|    bool finalize_hash = was_last_apdu;
  223|       |
  224|       |    // Update the hash, finalize if needed
  225|     97|    update_hash_twice(&tx_parser->signing.hasher, buffer, finalize_hash);
  226|       |
  227|     97|    if (was_last_apdu) {
  ------------------
  |  Branch (227:9): [True: 5, False: 92]
  ------------------
  228|      5|        if (!is_tx_fee_set(&tx_parser->transaction)) {
  ------------------
  |  Branch (228:13): [True: 2, False: 3]
  ------------------
  229|      2|            outcome->outcome_type = PARSE_PROCESS_INS_TX_DOES_NOT_CONTAIN_TX_FEE;
  230|      2|            return false;
  231|      2|        }
  232|       |
  233|      3|        if (tx_metadata->tx_bytes_received_count != tx_metadata->tx_byte_count) {
  ------------------
  |  Branch (233:13): [True: 0, False: 3]
  ------------------
  234|      0|            outcome->outcome_type = PARSE_PROCESS_INS_BYTE_COUNT_MISMATCH;
  235|      0|            return false;
  236|      0|        }
  237|       |
  238|      3|        outcome->outcome_type = PARSE_PROCESS_INS_SUCCESS_FINISHED_PARSING_WHOLE_TRANSACTION;
  239|      3|        return true;
  240|     92|    } else {
  241|     92|        outcome->outcome_type = PARSE_PROCESS_INS_SUCCESS_FINISHED_PARSING_INS;
  242|     92|        return true;
  243|     92|    }
  244|     97|}
init_tx_parser_with_config:
  282|     32|                                init_tx_parser_outcome_t *outcome) {
  283|     32|    if (!validate_tx_parser_config_tx_metadata(&config->transaction_metadata)) {
  ------------------
  |  Branch (283:9): [True: 0, False: 32]
  ------------------
  284|      0|        outcome->outcome_type = INIT_TX_PARSER_INVALID_TX_METADATA_IN_CONFIG;
  285|      0|        return false;
  286|      0|    }
  287|       |
  288|       |    // Copy over `transaction_metadata` from `config`
  289|     32|    memmove(&tx_parser->transaction_metadata,
  290|     32|            &config->transaction_metadata,
  291|     32|            sizeof(config->transaction_metadata));
  292|       |
  293|       |    // Copy over `instruction_display_config` from `config`
  294|     32|    memmove(&tx_parser->instruction_display_config,
  295|     32|            &config->instruction_display_config,
  296|     32|            sizeof(config->instruction_display_config));
  297|       |
  298|       |    // Copy over `bip32_path` from `config`
  299|     32|    memmove(&tx_parser->signing.my_derived_public_key.bip32_path,
  300|     32|            &config->bip32_path,
  301|     32|            sizeof(config->bip32_path));
  302|       |
  303|       |    // Need our public key to compare against recipient addresses in transfer/stake to identify
  304|       |    // spent amount and amounts being change back to ourselves
  305|     32|    if (!derive_my_pubkey(&tx_parser->signing.my_derived_public_key)) {
  ------------------
  |  Branch (305:9): [True: 0, False: 32]
  ------------------
  306|      0|        outcome->outcome_type = INIT_TX_PARSER_FAILED_TO_DERIVE_MY_PUBLIC_KEY;
  307|      0|        return false;
  308|      0|    }
  309|       |
  310|       |    // Setup hasher
  311|     32|    init_hasher(&tx_parser->signing.hasher, sha_256_once, reinit_implementing_hasher);
  312|       |
  313|       |    // Setup instruction parser
  314|     32|    setup_instruction_parser(&tx_parser->instruction_parser);
  315|       |
  316|     32|    return true;
  317|     32|}
transaction_parser.c:update_tx_fee_and_total_xrd_cost_if_needed:
   76|     12|                                                       transaction_t *transaction) {
   77|     12|    bool sys_call_is_tx_fee_put =
   78|     12|        (bool) syscall->call_data.data[0] == INS_SYSCALL_TX_FEE_RESERVE_PUT;
  ------------------
  |  |   16|     12|#define INS_SYSCALL_TX_FEE_RESERVE_PUT  0x00
  ------------------
   79|     12|    bool sys_call_is_tx_fee_take =
   80|     12|        (bool) syscall->call_data.data[0] == INS_SYSCALL_TX_FEE_RESERVE_TAKE;
  ------------------
  |  |   17|     12|#define INS_SYSCALL_TX_FEE_RESERVE_TAKE 0x01
  ------------------
   81|       |
   82|     12|    if (!sys_call_is_tx_fee_put && !sys_call_is_tx_fee_take) {
  ------------------
  |  Branch (82:9): [True: 5, False: 7]
  |  Branch (82:36): [True: 0, False: 5]
  ------------------
   83|      0|        return true;
   84|      0|    }
   85|       |
   86|       |    // SYSCALL specifies TX fee
   87|     12|    uint256_t amount;
   88|     12|    uint256_t tmp;
   89|       |
   90|     12|    if (!parse_tx_fee_from_syscall(syscall, &amount)) {
  ------------------
  |  Branch (90:9): [True: 2, False: 10]
  ------------------
   91|      2|        return false;
   92|      2|    }
   93|       |
   94|     10|    if (sys_call_is_tx_fee_put) {
  ------------------
  |  Branch (94:9): [True: 7, False: 3]
  ------------------
   95|      7|        if (is_tx_fee_set(transaction)) {
  ------------------
  |  Branch (95:13): [True: 0, False: 7]
  ------------------
   96|       |            // Invalid state, a transaction must not specify more than one SYSCALL with
   97|       |            // `TX_FEE_RESERVE_PUT`.
   98|      0|            return false;
   99|      0|        }
  100|       |
  101|       |        // Copy over tx fee.
  102|      7|        copy256(&transaction->tx_fee, &amount);
  103|       |
  104|       |        // Save current amount to avoid in-place update
  105|      7|        copy256(&tmp, &transaction->total_xrd_amount_incl_fee);
  106|       |
  107|       |        // Add tx fee to total cost
  108|      7|        add256(&amount, &tmp, &transaction->total_xrd_amount_incl_fee);
  109|       |
  110|      7|    } else if (sys_call_is_tx_fee_take) {
  ------------------
  |  Branch (110:16): [True: 3, False: 0]
  ------------------
  111|      3|        if (!is_tx_fee_set(transaction)) {
  ------------------
  |  Branch (111:13): [True: 0, False: 3]
  ------------------
  112|       |            // Invalid state, a transaction must first specify one (and only one) SYSCALL
  113|       |            // with `TX_FEE_RESERVE_PUT` before it specifies SYSCALLs with
  114|       |            // `INS_SYSCALL_TX_FEE_RESERVE_TAKE`. We just parsed a `TX_FEE_RESERVE_TAKE`,
  115|       |            // but tx fee is zero, meaning we did not earlier parse `TX_FEE_RESERVE_PUT`.
  116|      0|            return false;
  117|      0|        }
  118|       |
  119|      3|        if (gt256(&amount, &transaction->tx_fee) ||
  ------------------
  |  Branch (119:13): [True: 0, False: 3]
  ------------------
  120|      3|            gt256(&amount, &transaction->total_xrd_amount_incl_fee)) {
  ------------------
  |  Branch (120:13): [True: 0, False: 3]
  ------------------
  121|       |            // Invalid state, just parsed a `TX_FEE_RESERVE_TAKE` which was larger than
  122|       |            // amount left from put. This would result in a negative tx fee.
  123|      0|            return false;
  124|      0|        }
  125|       |
  126|       |        // Save current amount to avoid in-place update
  127|      3|        copy256(&tmp, &transaction->tx_fee);
  128|       |
  129|       |        // TX_FEE = TX_FEE - TX_FEE_RESERVE_TAKE
  130|      3|        minus256(&tmp, &amount, &transaction->tx_fee);
  131|       |
  132|       |        // Save current amount to avoid in-place update
  133|      3|        copy256(&tmp, &transaction->total_xrd_amount_incl_fee);
  134|       |
  135|       |        // TOTAL_XRD_COST = TOTAL_XRD_COST - TX_FEE_RESERVE_TAKE
  136|      3|        minus256(&tmp, &amount, &transaction->total_xrd_amount_incl_fee);
  137|      3|    }
  138|       |
  139|     10|    return true;
  140|     10|}
transaction_parser.c:validate_tx_parser_config_tx_metadata:
  246|     32|static bool validate_tx_parser_config_tx_metadata(transaction_metadata_t *metadata) {
  247|     32|    if (metadata->tx_byte_count < 1) {
  ------------------
  |  Branch (247:9): [True: 0, False: 32]
  ------------------
  248|       |        // Must have at at least one byte to sign.
  249|      0|        PRINTF("Invalid Tx Parser Config MetaData: TX byte count.\n");
  250|      0|        return false;
  251|      0|    }
  252|     32|    if (metadata->tx_bytes_received_count != 0) {
  ------------------
  |  Branch (252:9): [True: 0, False: 32]
  ------------------
  253|       |        // Must start at 0
  254|      0|        PRINTF("Invalid Tx Parser Config MetaData: TX recieved byte count.\n");
  255|      0|        return false;
  256|      0|    }
  257|       |
  258|     32|    if (metadata->total_number_of_instructions < 1) {
  ------------------
  |  Branch (258:9): [True: 0, False: 32]
  ------------------
  259|       |        // Must have at least one instruction to sign.
  260|      0|        PRINTF("Invalid Tx Parser Config MetaData: instruction count.\n");
  261|      0|        return false;
  262|      0|    }
  263|     32|    if (metadata->number_of_instructions_received != 0) {
  ------------------
  |  Branch (263:9): [True: 0, False: 32]
  ------------------
  264|       |        // Must start at 0
  265|      0|        PRINTF("Invalid Tx Parser Config MetaData: received instruction count.\n");
  266|      0|        return false;
  267|      0|    }
  268|       |
  269|     32|    return true;
  270|     32|}
transaction_parser.c:setup_instruction_parser:
  272|     32|static void setup_instruction_parser(instruction_parser_t *ins_parser) {
  273|       |    // Setup state
  274|     32|    ins_parser->state = STATE_PARSE_INS_READY_TO_PARSE;
  275|     32|}

number_of_remaining_bytes_in_buffer:
   27|    408|size_t number_of_remaining_bytes_in_buffer(const buffer_t *buffer) {
   28|    408|    return buffer->size - buffer->offset;
   29|    408|}
buffer_can_read:
   31|    543|bool buffer_can_read(const buffer_t *buffer, size_t n) {
   32|    543|    return buffer->size - buffer->offset >= n;
   33|    543|}
buffer_seek_cur:
   45|    608|bool buffer_seek_cur(buffer_t *buffer, size_t offset) {
   46|    608|    if (buffer->offset + offset < buffer->offset) {
  ------------------
  |  Branch (46:9): [True: 0, False: 608]
  ------------------
   47|       |        // overflow
   48|      0|        PRINTF("`buffer_seek_cur` failed, because of overflow.\n");
   49|      0|        return false;
   50|      0|    }
   51|    608|    if (buffer->offset + offset > buffer->size) {
  ------------------
  |  Branch (51:9): [True: 0, False: 608]
  ------------------
   52|       |        // exceed buffer size
   53|      0|        PRINTF("`buffer_seek_cur` failed, because buffer size exceeded.\n");
   54|      0|        return false;
   55|      0|    }
   56|       |
   57|    608|    buffer->offset += offset;
   58|       |
   59|    608|    return true;
   60|    608|}
buffer_read_u8:
   72|    467|bool buffer_read_u8(buffer_t *buffer, uint8_t *value) {
   73|    467|    if (!buffer_can_read(buffer, 1)) {
  ------------------
  |  Branch (73:9): [True: 0, False: 467]
  ------------------
   74|      0|        *value = 0;
   75|       |
   76|      0|        return false;
   77|      0|    }
   78|       |
   79|    467|    *value = buffer->ptr[buffer->offset];
   80|    467|    buffer_seek_cur(buffer, 1);
   81|       |
   82|    467|    return true;
   83|    467|}
buffer_read_u16:
   85|     54|bool buffer_read_u16(buffer_t *buffer, uint16_t *value, endianness_t endianness) {
   86|     54|    if (!buffer_can_read(buffer, 2)) {
  ------------------
  |  Branch (86:9): [True: 8, False: 46]
  ------------------
   87|      8|        *value = 0;
   88|       |
   89|      8|        return false;
   90|      8|    }
   91|       |
   92|     46|    *value = ((endianness == BE) ? read_u16_be(buffer->ptr, buffer->offset)
  ------------------
  |  Branch (92:15): [True: 46, False: 0]
  ------------------
   93|     46|                                 : read_u16_le(buffer->ptr, buffer->offset));
   94|       |
   95|     46|    buffer_seek_cur(buffer, 2);
   96|       |
   97|     46|    return true;
   98|     54|}
buffer_read_u32:
  100|     22|bool buffer_read_u32(buffer_t *buffer, uint32_t *value, endianness_t endianness) {
  101|     22|    if (!buffer_can_read(buffer, 4)) {
  ------------------
  |  Branch (101:9): [True: 0, False: 22]
  ------------------
  102|      0|        *value = 0;
  103|       |
  104|      0|        return false;
  105|      0|    }
  106|       |
  107|     22|    *value = ((endianness == BE) ? read_u32_be(buffer->ptr, buffer->offset)
  ------------------
  |  Branch (107:15): [True: 22, False: 0]
  ------------------
  108|     22|                                 : read_u32_le(buffer->ptr, buffer->offset));
  109|       |
  110|     22|    buffer_seek_cur(buffer, 4);
  111|       |
  112|     22|    return true;
  113|     22|}
buffer_copy_some:
  143|    136|                      const size_t bytes_to_copy_count) {
  144|    136|    size_t remaining_byte_count = number_of_remaining_bytes_in_buffer(buffer);
  145|    136|    if (bytes_to_copy_count > out_len) {
  ------------------
  |  Branch (145:9): [True: 0, False: 136]
  ------------------
  146|      0|        PRINTF(
  147|      0|            "'buffer_copy_some' is failing, because `bytes_to_copy_count`: %d, is larger than "
  148|      0|            "`out_len`: %d.\n",
  149|      0|            bytes_to_copy_count,
  150|      0|            out_len);
  151|      0|        debug_print_buffer(buffer);
  152|      0|        return false;
  153|      0|    }
  154|       |
  155|    136|    if (bytes_to_copy_count > remaining_byte_count) {
  ------------------
  |  Branch (155:9): [True: 63, False: 73]
  ------------------
  156|     63|        PRINTF(
  157|     63|            "'buffer_copy_some' is failing, because `bytes_to_copy_count`: %d, is larger than "
  158|     63|            "`remaining_byte_count`: %d.\n",
  159|     63|            bytes_to_copy_count,
  160|     63|            remaining_byte_count);
  161|     63|        debug_print_buffer(buffer);
  162|     63|        return false;
  163|     63|    }
  164|       |
  165|     73|    memmove(out, buffer->ptr + buffer->offset, bytes_to_copy_count);
  166|       |
  167|     73|    return true;
  168|    136|}
buffer_move_some:
  181|    136|                      const size_t bytes_to_move_count) {
  182|    136|    if (!buffer_copy_some(buffer, out, out_len, bytes_to_move_count)) {
  ------------------
  |  Branch (182:9): [True: 63, False: 73]
  ------------------
  183|     63|        PRINTF("'buffer_move_some' is failing, because `buffer_copy_some` is failing.\n");
  184|     63|        return false;
  185|     63|    }
  186|       |
  187|     73|    if (!buffer_seek_cur(buffer, bytes_to_move_count)) {
  ------------------
  |  Branch (187:9): [True: 0, False: 73]
  ------------------
  188|      0|        PRINTF("'buffer_move_some' is failing, because `buffer_seek_cur` is failing\n.");
  189|      0|        return false;
  190|      0|    }
  191|       |
  192|     73|    return true;
  193|     73|}
buffer_move_fill_target:
  195|    136|bool buffer_move_fill_target(buffer_t *buffer, uint8_t *target, const size_t target_len) {
  196|    136|    return buffer_move_some(buffer, target, target_len, target_len);
  197|    136|}
debug_print_buffer:
  199|    138|void debug_print_buffer(const buffer_t *buffer) {
  200|    138|    size_t remaining_byte_count = number_of_remaining_bytes_in_buffer(buffer);
  201|    138|    UNUSED(remaining_byte_count);  // If debug build 'remaining_byte_count' is considered unused.
  ------------------
  |  |    8|    138|#define UNUSED(x) (void) x
  ------------------
  202|    138|    PRINTF("\n\n~~~ BUFFER ~~~\n");
  203|       |
  204|    138|    PRINTF("Size: #%d bytes\n", buffer->size);
  205|    138|    PRINTF("Offset: @%d\n", buffer->offset);
  206|    138|    PRINTF("Bytes left: #%d bytes\n", remaining_byte_count);
  207|       |
  208|    138|    PRINTF("Remaining bytes: %.*h\n", remaining_byte_count, (buffer->ptr + buffer->offset));
  209|    138|    PRINTF("~~~ END ~~~\n\n\n");
  210|    138|}

init_hasher:
    8|     32|                 init_implementing_hasher_fn init_implementing_hasher) {
    9|     32|    explicit_bzero(hasher, sizeof(*hasher));
   10|     32|    init_implementing_hasher();
   11|     32|    hasher->sha_256_once = sha_256_once;
   12|     32|    hasher->reinit_implementing_hasher = init_implementing_hasher;
   13|     32|}
update_hash:
   15|    102|bool update_hash(hasher_t* hasher, buffer_t* buffer, bool finalize) {
   16|    102|    sha_256_once_fn sha_256_once = hasher->sha_256_once;
   17|    102|    return sha_256_once(buffer, finalize, hasher->hash);
   18|    102|}
update_hash_twice:
   20|     97|bool update_hash_twice(hasher_t* hasher, buffer_t* buffer, bool finalize) {
   21|     97|    if (!update_hash(hasher, buffer, finalize)) {
  ------------------
  |  Branch (21:9): [True: 0, False: 97]
  ------------------
   22|      0|        return false;
   23|      0|    }
   24|       |
   25|     97|    if (finalize) {
  ------------------
  |  Branch (25:9): [True: 5, False: 92]
  ------------------
   26|      5|        init_implementing_hasher_fn reinit_implementing_hasher = hasher->reinit_implementing_hasher;
   27|       |        // Prepare implementing hasher for a second pass.
   28|      5|        reinit_implementing_hasher();
   29|       |
   30|       |        // tmp copy of firstHash
   31|      5|        uint8_t hashed_once[HASH_LEN];
   32|      5|        memmove(hashed_once, hasher->hash, HASH_LEN);
  ------------------
  |  |   48|      5|#define HASH_LEN 32
  ------------------
   33|      5|        buffer_t second_buf = (buffer_t){
   34|      5|            .offset = 0,
   35|      5|            .ptr = hashed_once,
   36|      5|            .size = HASH_LEN,
  ------------------
  |  |   48|      5|#define HASH_LEN 32
  ------------------
   37|      5|        };
   38|       |
   39|      5|        if (!update_hash(hasher, &second_buf, true)) {
  ------------------
  |  Branch (39:13): [True: 0, False: 5]
  ------------------
   40|      0|            return false;
   41|      0|        }
   42|       |
   43|      5|        PRINTF("Finalized hash to: '%.*h'\n", HASH_LEN, hasher->hash);
   44|      5|    }
   45|       |
   46|     97|    return true;
   47|     97|}

public_key_equals:
    3|     14|bool public_key_equals(public_key_t *lhs, public_key_t *rhs) {
    4|    113|    for (int i = 0; i < PUBLIC_KEY_COMPRESSED_LEN; ++i) {
  ------------------
  |  |   60|    113|#define PUBLIC_KEY_COMPRESSED_LEN 33
  ------------------
  |  Branch (4:21): [True: 110, False: 3]
  ------------------
    5|    110|        if (lhs->compressed[i] != rhs->compressed[i]) {
  ------------------
  |  Branch (5:13): [True: 11, False: 99]
  ------------------
    6|     11|            return false;
    7|     11|        }
    8|    110|    }
    9|      3|    return true;
   10|     14|}

parse_re_address:
   32|     33|                      re_address_t *address) {
   33|     33|    uint8_t address_type_value;
   34|     33|    if (!buffer_read_u8(buffer, &address_type_value) ||
  ------------------
  |  Branch (34:9): [True: 0, False: 33]
  ------------------
   35|     33|        !is_re_address_type_known((int) address_type_value)) {
  ------------------
  |  Branch (35:9): [True: 2, False: 31]
  ------------------
   36|      2|        *failure_reason = PARSE_ADDRESS_FAIL_UNRECOGNIZED_ADDRESS_TYPE;
   37|      2|        return false;
   38|      2|    }
   39|       |
   40|     31|    if (!is_re_address_type_supported((int) address_type_value)) {
  ------------------
  |  Branch (40:9): [True: 0, False: 31]
  ------------------
   41|      0|        *failure_reason = PARSE_ADDRESS_FAIL_UNSUPPORTED_ADDRESS_TYPE;
   42|      0|        return false;
   43|      0|    }
   44|     31|    re_address_type_e address_type = (re_address_type_e) address_type_value;
   45|       |
   46|       |    // print_re_address_type(address_type);
   47|       |
   48|     31|    address->address_type = address_type;
   49|       |
   50|     31|    switch (address_type) {
  ------------------
  |  Branch (50:13): [True: 0, False: 31]
  ------------------
   51|     10|        case RE_ADDRESS_NATIVE_TOKEN:
  ------------------
  |  Branch (51:9): [True: 10, False: 21]
  ------------------
   52|     10|            break;
   53|      4|        case RE_ADDRESS_HASHED_KEY_NONCE:
  ------------------
  |  Branch (53:9): [True: 4, False: 27]
  ------------------
   54|      4|            if (!buffer_move_fill_target(buffer, address->hashed_key, RE_ADDR_HASHED_KEY_LEN)) {
  ------------------
  |  |   18|      4|#define RE_ADDR_HASHED_KEY_LEN 26
  ------------------
  |  Branch (54:17): [True: 0, False: 4]
  ------------------
   55|      0|                *failure_reason = PARSE_ADDRESS_FAIL_HASHEDKEY_NOT_ENOUGH_BYTES;
   56|      0|                return false;
   57|      0|            }
   58|      4|            break;
   59|     17|        case RE_ADDRESS_PUBLIC_KEY:
  ------------------
  |  Branch (59:9): [True: 17, False: 14]
  ------------------
   60|     17|            if (!buffer_move_fill_target(buffer,
  ------------------
  |  Branch (60:17): [True: 1, False: 16]
  ------------------
   61|     17|                                         address->public_key.compressed,
   62|     17|                                         PUBLIC_KEY_COMPRESSED_LEN)) {
  ------------------
  |  |   60|     17|#define PUBLIC_KEY_COMPRESSED_LEN 33
  ------------------
   63|      1|                *failure_reason = PARSE_ADDRESS_FAIL_PUBKEY_NOT_ENOUGH_BYTES;
   64|      1|                return false;
   65|      1|            }
   66|     16|            break;
   67|     31|    }
   68|       |
   69|     30|    return true;
   70|     31|}

is_re_address_type_known:
    3|     33|bool is_re_address_type_known(int raw) {
    4|     33|    return raw <= RE_ADDRESS_PUBLIC_KEY;
    5|     33|}
is_re_address_type_supported:
    7|     31|bool is_re_address_type_supported(int raw) {
    8|     31|    switch (raw) {
  ------------------
  |  Branch (8:13): [True: 0, False: 31]
  ------------------
    9|     10|        case RE_ADDRESS_NATIVE_TOKEN:
  ------------------
  |  Branch (9:9): [True: 10, False: 21]
  ------------------
   10|     14|        case RE_ADDRESS_HASHED_KEY_NONCE:
  ------------------
  |  Branch (10:9): [True: 4, False: 27]
  ------------------
   11|     31|        case RE_ADDRESS_PUBLIC_KEY:
  ------------------
  |  Branch (11:9): [True: 17, False: 14]
  ------------------
   12|     31|            return true;
   13|     31|    }
   14|      0|    return false;
   15|     31|}

parse_re_bytes:
    6|     34|bool parse_re_bytes(buffer_t *buffer, parse_bytes_outcome_e *outcome, re_bytes_t *bytes) {
    7|     34|    if (!buffer_read_u16(buffer, &bytes->length, BE)) {
  ------------------
  |  Branch (7:9): [True: 8, False: 26]
  ------------------
    8|      8|        PRINTF("Failed to parse length of RE bytes.\n");
    9|      8|        *outcome = PARSE_BYTES_FAILED_TO_PARSE_LENGTH;
   10|      8|        return false;
   11|      8|    }
   12|     26|    if (!buffer_move_fill_target(buffer, bytes->data, bytes->length)) {
  ------------------
  |  Branch (12:9): [True: 9, False: 17]
  ------------------
   13|      9|        PRINTF("Failed to parse RE bytes, wrong length, first byte specified length of %d\n",
   14|      9|               bytes->length);
   15|      9|        *outcome = PARSE_BYTES_FAIL_WRONG_LENGTH;
   16|      9|        return false;
   17|      9|    }
   18|       |
   19|     17|    *outcome = PARSE_BYTES_OK;
   20|       |
   21|     17|    return true;
   22|     26|}

is_uint256_greater_than_zero:
  313|     15|bool is_uint256_greater_than_zero(const uint256_t *target) {
  314|     15|    return gt256(target, &ZERO);
  315|     15|}
add256:
  317|     16|void add256(const uint256_t *number1, const uint256_t *number2, uint256_t *target) {
  318|     16|    uint128_t tmp;
  319|     16|    add128(&UPPER_P(number1), &UPPER_P(number2), &UPPER_P(target));
  ------------------
  |  |   35|     16|#define UPPER_P(x) x->elements[0]
  ------------------
                  add128(&UPPER_P(number1), &UPPER_P(number2), &UPPER_P(target));
  ------------------
  |  |   35|     16|#define UPPER_P(x) x->elements[0]
  ------------------
                  add128(&UPPER_P(number1), &UPPER_P(number2), &UPPER_P(target));
  ------------------
  |  |   35|     16|#define UPPER_P(x) x->elements[0]
  ------------------
  320|     16|    add128(&LOWER_P(number1), &LOWER_P(number2), &tmp);
  ------------------
  |  |   36|     16|#define LOWER_P(x) x->elements[1]
  ------------------
                  add128(&LOWER_P(number1), &LOWER_P(number2), &tmp);
  ------------------
  |  |   36|     16|#define LOWER_P(x) x->elements[1]
  ------------------
  321|     16|    if (gt128(&LOWER_P(number1), &tmp)) {
  ------------------
  |  |   36|     16|#define LOWER_P(x) x->elements[1]
  ------------------
  |  Branch (321:9): [True: 0, False: 16]
  ------------------
  322|      0|        uint128_t one;
  323|      0|        UPPER(one) = 0;
  ------------------
  |  |   37|      0|#define UPPER(x)   x.elements[0]
  ------------------
  324|      0|        LOWER(one) = 1;
  ------------------
  |  |   38|      0|#define LOWER(x)   x.elements[1]
  ------------------
  325|      0|        add128(&UPPER_P(target), &one, &UPPER_P(target));
  ------------------
  |  |   35|      0|#define UPPER_P(x) x->elements[0]
  ------------------
                      add128(&UPPER_P(target), &one, &UPPER_P(target));
  ------------------
  |  |   35|      0|#define UPPER_P(x) x->elements[0]
  ------------------
  326|      0|    }
  327|     16|    add128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
  ------------------
  |  |   36|     16|#define LOWER_P(x) x->elements[1]
  ------------------
                  add128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
  ------------------
  |  |   36|     16|#define LOWER_P(x) x->elements[1]
  ------------------
                  add128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
  ------------------
  |  |   36|     16|#define LOWER_P(x) x->elements[1]
  ------------------
  328|     16|}
minus256:
  330|      6|void minus256(const uint256_t *number1, const uint256_t *number2, uint256_t *target) {
  331|      6|    uint128_t tmp;
  332|      6|    minus128(&UPPER_P(number1), &UPPER_P(number2), &UPPER_P(target));
  ------------------
  |  |   35|      6|#define UPPER_P(x) x->elements[0]
  ------------------
                  minus128(&UPPER_P(number1), &UPPER_P(number2), &UPPER_P(target));
  ------------------
  |  |   35|      6|#define UPPER_P(x) x->elements[0]
  ------------------
                  minus128(&UPPER_P(number1), &UPPER_P(number2), &UPPER_P(target));
  ------------------
  |  |   35|      6|#define UPPER_P(x) x->elements[0]
  ------------------
  333|      6|    minus128(&LOWER_P(number1), &LOWER_P(number2), &tmp);
  ------------------
  |  |   36|      6|#define LOWER_P(x) x->elements[1]
  ------------------
                  minus128(&LOWER_P(number1), &LOWER_P(number2), &tmp);
  ------------------
  |  |   36|      6|#define LOWER_P(x) x->elements[1]
  ------------------
  334|      6|    if (gt128(&tmp, &LOWER_P(number1))) {
  ------------------
  |  |   36|      6|#define LOWER_P(x) x->elements[1]
  ------------------
  |  Branch (334:9): [True: 0, False: 6]
  ------------------
  335|      0|        uint128_t one;
  336|      0|        UPPER(one) = 0;
  ------------------
  |  |   37|      0|#define UPPER(x)   x.elements[0]
  ------------------
  337|      0|        LOWER(one) = 1;
  ------------------
  |  |   38|      0|#define LOWER(x)   x.elements[1]
  ------------------
  338|      0|        minus128(&UPPER_P(target), &one, &UPPER_P(target));
  ------------------
  |  |   35|      0|#define UPPER_P(x) x->elements[0]
  ------------------
                      minus128(&UPPER_P(target), &one, &UPPER_P(target));
  ------------------
  |  |   35|      0|#define UPPER_P(x) x->elements[0]
  ------------------
  339|      0|    }
  340|      6|    minus128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
  ------------------
  |  |   36|      6|#define LOWER_P(x) x->elements[1]
  ------------------
                  minus128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
  ------------------
  |  |   36|      6|#define LOWER_P(x) x->elements[1]
  ------------------
                  minus128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
  ------------------
  |  |   36|      6|#define LOWER_P(x) x->elements[1]
  ------------------
  341|      6|}
readu256BE:
  343|     24|void readu256BE(uint8_t *buffer, uint256_t *target) {
  344|     24|    readu128BE(buffer, &UPPER_P(target));
  ------------------
  |  |   35|     24|#define UPPER_P(x) x->elements[0]
  ------------------
  345|     24|    readu128BE(buffer + 16, &LOWER_P(target));
  ------------------
  |  |   36|     24|#define LOWER_P(x) x->elements[1]
  ------------------
  346|     24|}
uint256_from_buffer:
  348|     14|bool uint256_from_buffer(buffer_t *buffer, uint256_t *target) {
  349|     14|    uint8_t temp[UINT256_BYTE_COUNT];
  350|     14|    if (!buffer_move_fill_target(buffer, temp, UINT256_BYTE_COUNT)) {
  ------------------
  |  |   50|     14|#define UINT256_BYTE_COUNT            32
  ------------------
  |  Branch (350:9): [True: 0, False: 14]
  ------------------
  351|      0|        PRINTF("Failed to parse uint256 from buffer.\n");
  352|      0|        return false;
  353|      0|    }
  354|     14|    readu256BE(temp, target);
  355|     14|    return true;
  356|     14|}
copy256:
  358|     29|void copy256(uint256_t *target, const uint256_t *number) {
  359|     29|    copy128(&UPPER_P(target), &UPPER_P(number));
  ------------------
  |  |   35|     29|#define UPPER_P(x) x->elements[0]
  ------------------
                  copy128(&UPPER_P(target), &UPPER_P(number));
  ------------------
  |  |   35|     29|#define UPPER_P(x) x->elements[0]
  ------------------
  360|     29|    copy128(&LOWER_P(target), &LOWER_P(number));
  ------------------
  |  |   36|     29|#define LOWER_P(x) x->elements[1]
  ------------------
                  copy128(&LOWER_P(target), &LOWER_P(number));
  ------------------
  |  |   36|     29|#define LOWER_P(x) x->elements[1]
  ------------------
  361|     29|}
gt256:
  368|     21|bool gt256(const uint256_t *number1, const uint256_t *number2) {
  369|     21|    if (equal128(&UPPER_P(number1), &UPPER_P(number2))) {
  ------------------
  |  |   35|     21|#define UPPER_P(x) x->elements[0]
  ------------------
                  if (equal128(&UPPER_P(number1), &UPPER_P(number2))) {
  ------------------
  |  |   35|     21|#define UPPER_P(x) x->elements[0]
  ------------------
  |  Branch (369:9): [True: 21, False: 0]
  ------------------
  370|     21|        return gt128(&LOWER_P(number1), &LOWER_P(number2));
  ------------------
  |  |   36|     21|#define LOWER_P(x) x->elements[1]
  ------------------
                      return gt128(&LOWER_P(number1), &LOWER_P(number2));
  ------------------
  |  |   36|     21|#define LOWER_P(x) x->elements[1]
  ------------------
  371|     21|    }
  372|      0|    return gt128(&UPPER_P(number1), &UPPER_P(number2));
  ------------------
  |  |   35|      0|#define UPPER_P(x) x->elements[0]
  ------------------
                  return gt128(&UPPER_P(number1), &UPPER_P(number2));
  ------------------
  |  |   35|      0|#define UPPER_P(x) x->elements[0]
  ------------------
  373|     21|}
uint256.c:add128:
  102|     48|static void add128(const uint128_t *number1, const uint128_t *number2, uint128_t *target) {
  103|     48|    UPPER_P(target) = UPPER_P(number1) + UPPER_P(number2) +
  ------------------
  |  |   35|     48|#define UPPER_P(x) x->elements[0]
  ------------------
                  UPPER_P(target) = UPPER_P(number1) + UPPER_P(number2) +
  ------------------
  |  |   35|     48|#define UPPER_P(x) x->elements[0]
  ------------------
                  UPPER_P(target) = UPPER_P(number1) + UPPER_P(number2) +
  ------------------
  |  |   35|     48|#define UPPER_P(x) x->elements[0]
  ------------------
  104|     48|                      ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
  ------------------
  |  |   36|     48|#define LOWER_P(x) x->elements[1]
  ------------------
                                    ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
  ------------------
  |  |   36|     48|#define LOWER_P(x) x->elements[1]
  ------------------
                                    ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
  ------------------
  |  |   36|     48|#define LOWER_P(x) x->elements[1]
  ------------------
  105|     48|    LOWER_P(target) = LOWER_P(number1) + LOWER_P(number2);
  ------------------
  |  |   36|     48|#define LOWER_P(x) x->elements[1]
  ------------------
                  LOWER_P(target) = LOWER_P(number1) + LOWER_P(number2);
  ------------------
  |  |   36|     48|#define LOWER_P(x) x->elements[1]
  ------------------
                  LOWER_P(target) = LOWER_P(number1) + LOWER_P(number2);
  ------------------
  |  |   36|     48|#define LOWER_P(x) x->elements[1]
  ------------------
  106|     48|}
uint256.c:gt128:
  188|     43|static bool gt128(const uint128_t *number1, const uint128_t *number2) {
  189|     43|    if (UPPER_P(number1) == UPPER_P(number2)) {
  ------------------
  |  |   35|     43|#define UPPER_P(x) x->elements[0]
  ------------------
                  if (UPPER_P(number1) == UPPER_P(number2)) {
  ------------------
  |  |   35|     86|#define UPPER_P(x) x->elements[0]
  ------------------
  |  Branch (189:9): [True: 24, False: 19]
  ------------------
  190|     24|        return (LOWER_P(number1) > LOWER_P(number2));
  ------------------
  |  |   36|     24|#define LOWER_P(x) x->elements[1]
  ------------------
                      return (LOWER_P(number1) > LOWER_P(number2));
  ------------------
  |  |   36|     24|#define LOWER_P(x) x->elements[1]
  ------------------
  191|     24|    }
  192|     19|    return (UPPER_P(number1) > UPPER_P(number2));
  ------------------
  |  |   35|     19|#define UPPER_P(x) x->elements[0]
  ------------------
                  return (UPPER_P(number1) > UPPER_P(number2));
  ------------------
  |  |   35|     19|#define UPPER_P(x) x->elements[0]
  ------------------
  193|     43|}
uint256.c:minus128:
  199|     18|static void minus128(const uint128_t *number1, const uint128_t *number2, uint128_t *target) {
  200|     18|    UPPER_P(target) = UPPER_P(number1) - UPPER_P(number2) -
  ------------------
  |  |   35|     18|#define UPPER_P(x) x->elements[0]
  ------------------
                  UPPER_P(target) = UPPER_P(number1) - UPPER_P(number2) -
  ------------------
  |  |   35|     18|#define UPPER_P(x) x->elements[0]
  ------------------
                  UPPER_P(target) = UPPER_P(number1) - UPPER_P(number2) -
  ------------------
  |  |   35|     18|#define UPPER_P(x) x->elements[0]
  ------------------
  201|     18|                      ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
  ------------------
  |  |   36|     18|#define LOWER_P(x) x->elements[1]
  ------------------
                                    ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
  ------------------
  |  |   36|     18|#define LOWER_P(x) x->elements[1]
  ------------------
                                    ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
  ------------------
  |  |   36|     18|#define LOWER_P(x) x->elements[1]
  ------------------
  202|     18|    LOWER_P(target) = LOWER_P(number1) - LOWER_P(number2);
  ------------------
  |  |   36|     18|#define LOWER_P(x) x->elements[1]
  ------------------
                  LOWER_P(target) = LOWER_P(number1) - LOWER_P(number2);
  ------------------
  |  |   36|     18|#define LOWER_P(x) x->elements[1]
  ------------------
                  LOWER_P(target) = LOWER_P(number1) - LOWER_P(number2);
  ------------------
  |  |   36|     18|#define LOWER_P(x) x->elements[1]
  ------------------
  203|     18|}
uint256.c:readu128BE:
   39|     48|static void readu128BE(uint8_t *buffer, uint128_t *target) {
   40|     48|    UPPER_P(target) = readUint64BE(buffer);
  ------------------
  |  |   35|     48|#define UPPER_P(x) x->elements[0]
  ------------------
   41|     48|    LOWER_P(target) = readUint64BE(buffer + 8);
  ------------------
  |  |   36|     48|#define LOWER_P(x) x->elements[1]
  ------------------
   42|     48|}
uint256.c:readUint64BE:
   32|     96|static uint64_t readUint64BE(uint8_t *buffer) {
   33|     96|    return (((uint64_t) buffer[0]) << 56) | (((uint64_t) buffer[1]) << 48) |
   34|     96|           (((uint64_t) buffer[2]) << 40) | (((uint64_t) buffer[3]) << 32) |
   35|     96|           (((uint64_t) buffer[4]) << 24) | (((uint64_t) buffer[5]) << 16) |
   36|     96|           (((uint64_t) buffer[6]) << 8) | (((uint64_t) buffer[7]));
   37|     96|}
uint256.c:copy128:
   52|     58|static void copy128(uint128_t *target, const uint128_t *number) {
   53|     58|    UPPER_P(target) = UPPER_P(number);
  ------------------
  |  |   35|     58|#define UPPER_P(x) x->elements[0]
  ------------------
                  UPPER_P(target) = UPPER_P(number);
  ------------------
  |  |   35|     58|#define UPPER_P(x) x->elements[0]
  ------------------
   54|     58|    LOWER_P(target) = LOWER_P(number);
  ------------------
  |  |   36|     58|#define LOWER_P(x) x->elements[1]
  ------------------
                  LOWER_P(target) = LOWER_P(number);
  ------------------
  |  |   36|     58|#define LOWER_P(x) x->elements[1]
  ------------------
   55|     58|}
uint256.c:equal128:
  179|     21|static bool equal128(const uint128_t *number1, const uint128_t *number2) {
  180|     21|    return (UPPER_P(number1) == UPPER_P(number2)) && (LOWER_P(number1) == LOWER_P(number2));
  ------------------
  |  |   35|     21|#define UPPER_P(x) x->elements[0]
  ------------------
                  return (UPPER_P(number1) == UPPER_P(number2)) && (LOWER_P(number1) == LOWER_P(number2));
  ------------------
  |  |   35|     21|#define UPPER_P(x) x->elements[0]
  ------------------
                  return (UPPER_P(number1) == UPPER_P(number2)) && (LOWER_P(number1) == LOWER_P(number2));
  ------------------
  |  |   36|     21|#define LOWER_P(x) x->elements[1]
  ------------------
                  return (UPPER_P(number1) == UPPER_P(number2)) && (LOWER_P(number1) == LOWER_P(number2));
  ------------------
  |  |   36|     21|#define LOWER_P(x) x->elements[1]
  ------------------
  |  Branch (180:12): [True: 21, False: 0]
  |  Branch (180:54): [True: 21, False: 0]
  ------------------
  181|     21|}

sha256_transform:
   45|     41|void sha256_transform(SHA256_CTX *ctx, const BYTE data[]) {
   46|     41|    WORD a, b, c, d, e, f, g, h, i, j, t1, t2, m[64];
   47|       |
   48|    697|    for (i = 0, j = 0; i < 16; ++i, j += 4)
  ------------------
  |  Branch (48:24): [True: 656, False: 41]
  ------------------
   49|    656|        m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]);
   50|  2.00k|    for (; i < 64; ++i) m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];
  ------------------
  |  |   31|  1.96k|#define SIG1(x)      (ROTRIGHT(x, 17) ^ ROTRIGHT(x, 19) ^ ((x) >> 10))
  |  |  ------------------
  |  |  |  |   24|  1.96k|#define ROTRIGHT(a, b) (((a) >> (b)) | ((a) << (32 - (b))))
  |  |  ------------------
  |  |               #define SIG1(x)      (ROTRIGHT(x, 17) ^ ROTRIGHT(x, 19) ^ ((x) >> 10))
  |  |  ------------------
  |  |  |  |   24|  1.96k|#define ROTRIGHT(a, b) (((a) >> (b)) | ((a) << (32 - (b))))
  |  |  ------------------
  ------------------
                  for (; i < 64; ++i) m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];
  ------------------
  |  |   30|  1.96k|#define SIG0(x)      (ROTRIGHT(x, 7) ^ ROTRIGHT(x, 18) ^ ((x) >> 3))
  |  |  ------------------
  |  |  |  |   24|  1.96k|#define ROTRIGHT(a, b) (((a) >> (b)) | ((a) << (32 - (b))))
  |  |  ------------------
  |  |               #define SIG0(x)      (ROTRIGHT(x, 7) ^ ROTRIGHT(x, 18) ^ ((x) >> 3))
  |  |  ------------------
  |  |  |  |   24|  1.96k|#define ROTRIGHT(a, b) (((a) >> (b)) | ((a) << (32 - (b))))
  |  |  ------------------
  ------------------
  |  Branch (50:12): [True: 1.96k, False: 41]
  ------------------
   51|       |
   52|     41|    a = ctx->state[0];
   53|     41|    b = ctx->state[1];
   54|     41|    c = ctx->state[2];
   55|     41|    d = ctx->state[3];
   56|     41|    e = ctx->state[4];
   57|     41|    f = ctx->state[5];
   58|     41|    g = ctx->state[6];
   59|     41|    h = ctx->state[7];
   60|       |
   61|  2.66k|    for (i = 0; i < 64; ++i) {
  ------------------
  |  Branch (61:17): [True: 2.62k, False: 41]
  ------------------
   62|  2.62k|        t1 = h + EP1(e) + CH(e, f, g) + k[i] + m[i];
  ------------------
  |  |   29|  2.62k|#define EP1(x)       (ROTRIGHT(x, 6) ^ ROTRIGHT(x, 11) ^ ROTRIGHT(x, 25))
  |  |  ------------------
  |  |  |  |   24|  2.62k|#define ROTRIGHT(a, b) (((a) >> (b)) | ((a) << (32 - (b))))
  |  |  ------------------
  |  |               #define EP1(x)       (ROTRIGHT(x, 6) ^ ROTRIGHT(x, 11) ^ ROTRIGHT(x, 25))
  |  |  ------------------
  |  |  |  |   24|  2.62k|#define ROTRIGHT(a, b) (((a) >> (b)) | ((a) << (32 - (b))))
  |  |  ------------------
  |  |               #define EP1(x)       (ROTRIGHT(x, 6) ^ ROTRIGHT(x, 11) ^ ROTRIGHT(x, 25))
  |  |  ------------------
  |  |  |  |   24|  2.62k|#define ROTRIGHT(a, b) (((a) >> (b)) | ((a) << (32 - (b))))
  |  |  ------------------
  ------------------
                      t1 = h + EP1(e) + CH(e, f, g) + k[i] + m[i];
  ------------------
  |  |   26|  2.62k|#define CH(x, y, z)  (((x) & (y)) ^ (~(x) & (z)))
  ------------------
   63|  2.62k|        t2 = EP0(a) + MAJ(a, b, c);
  ------------------
  |  |   28|  2.62k|#define EP0(x)       (ROTRIGHT(x, 2) ^ ROTRIGHT(x, 13) ^ ROTRIGHT(x, 22))
  |  |  ------------------
  |  |  |  |   24|  2.62k|#define ROTRIGHT(a, b) (((a) >> (b)) | ((a) << (32 - (b))))
  |  |  ------------------
  |  |               #define EP0(x)       (ROTRIGHT(x, 2) ^ ROTRIGHT(x, 13) ^ ROTRIGHT(x, 22))
  |  |  ------------------
  |  |  |  |   24|  2.62k|#define ROTRIGHT(a, b) (((a) >> (b)) | ((a) << (32 - (b))))
  |  |  ------------------
  |  |               #define EP0(x)       (ROTRIGHT(x, 2) ^ ROTRIGHT(x, 13) ^ ROTRIGHT(x, 22))
  |  |  ------------------
  |  |  |  |   24|  2.62k|#define ROTRIGHT(a, b) (((a) >> (b)) | ((a) << (32 - (b))))
  |  |  ------------------
  ------------------
                      t2 = EP0(a) + MAJ(a, b, c);
  ------------------
  |  |   27|  2.62k|#define MAJ(x, y, z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))
  ------------------
   64|  2.62k|        h = g;
   65|  2.62k|        g = f;
   66|  2.62k|        f = e;
   67|  2.62k|        e = d + t1;
   68|  2.62k|        d = c;
   69|  2.62k|        c = b;
   70|  2.62k|        b = a;
   71|  2.62k|        a = t1 + t2;
   72|  2.62k|    }
   73|       |
   74|     41|    ctx->state[0] += a;
   75|     41|    ctx->state[1] += b;
   76|     41|    ctx->state[2] += c;
   77|     41|    ctx->state[3] += d;
   78|     41|    ctx->state[4] += e;
   79|     41|    ctx->state[5] += f;
   80|     41|    ctx->state[6] += g;
   81|     41|    ctx->state[7] += h;
   82|     41|}
sha256_init:
   84|     37|void sha256_init(SHA256_CTX *ctx) {
   85|     37|    ctx->datalen = 0;
   86|     37|    ctx->bitlen = 0;
   87|     37|    ctx->state[0] = 0x6a09e667;
   88|     37|    ctx->state[1] = 0xbb67ae85;
   89|     37|    ctx->state[2] = 0x3c6ef372;
   90|     37|    ctx->state[3] = 0xa54ff53a;
   91|     37|    ctx->state[4] = 0x510e527f;
   92|     37|    ctx->state[5] = 0x9b05688c;
   93|     37|    ctx->state[6] = 0x1f83d9ab;
   94|     37|    ctx->state[7] = 0x5be0cd19;
   95|     37|}
sha256_update:
   97|    102|void sha256_update(SHA256_CTX *ctx, const BYTE data[], size_t len) {
   98|    102|    WORD i;
   99|       |
  100|  2.55k|    for (i = 0; i < len; ++i) {
  ------------------
  |  Branch (100:17): [True: 2.45k, False: 102]
  ------------------
  101|  2.45k|        ctx->data[ctx->datalen] = data[i];
  102|  2.45k|        ctx->datalen++;
  103|  2.45k|        if (ctx->datalen == 64) {
  ------------------
  |  Branch (103:13): [True: 31, False: 2.42k]
  ------------------
  104|     31|            sha256_transform(ctx, ctx->data);
  105|     31|            ctx->bitlen += 512;
  106|     31|            ctx->datalen = 0;
  107|     31|        }
  108|  2.45k|    }
  109|    102|}
sha256_final:
  111|     10|void sha256_final(SHA256_CTX *ctx, BYTE hash[]) {
  112|     10|    WORD i;
  113|       |
  114|     10|    i = ctx->datalen;
  115|       |
  116|       |    // Pad whatever data is left in the buffer.
  117|     10|    if (ctx->datalen < 56) {
  ------------------
  |  Branch (117:9): [True: 10, False: 0]
  ------------------
  118|     10|        ctx->data[i++] = 0x80;
  119|    228|        while (i < 56) ctx->data[i++] = 0x00;
  ------------------
  |  Branch (119:16): [True: 218, False: 10]
  ------------------
  120|     10|    } else {
  121|      0|        ctx->data[i++] = 0x80;
  122|      0|        while (i < 64) ctx->data[i++] = 0x00;
  ------------------
  |  Branch (122:16): [True: 0, False: 0]
  ------------------
  123|      0|        sha256_transform(ctx, ctx->data);
  124|      0|        memset(ctx->data, 0, 56);
  125|      0|    }
  126|       |
  127|       |    // Append to the padding the total message's length in bits and transform.
  128|     10|    ctx->bitlen += ctx->datalen * 8;
  129|     10|    ctx->data[63] = ctx->bitlen;
  130|     10|    ctx->data[62] = ctx->bitlen >> 8;
  131|     10|    ctx->data[61] = ctx->bitlen >> 16;
  132|     10|    ctx->data[60] = ctx->bitlen >> 24;
  133|     10|    ctx->data[59] = ctx->bitlen >> 32;
  134|     10|    ctx->data[58] = ctx->bitlen >> 40;
  135|     10|    ctx->data[57] = ctx->bitlen >> 48;
  136|     10|    ctx->data[56] = ctx->bitlen >> 56;
  137|     10|    sha256_transform(ctx, ctx->data);
  138|       |
  139|       |    // Since this implementation uses little endian byte ordering and SHA uses big endian,
  140|       |    // reverse all the bytes when copying the final state to the output hash.
  141|     50|    for (i = 0; i < 4; ++i) {
  ------------------
  |  Branch (141:17): [True: 40, False: 10]
  ------------------
  142|     40|        hash[i] = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;
  143|     40|        hash[i + 4] = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;
  144|     40|        hash[i + 8] = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;
  145|     40|        hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;
  146|     40|        hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;
  147|     40|        hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff;
  148|     40|        hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff;
  149|     40|        hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff;
  150|     40|    }
  151|     10|}

